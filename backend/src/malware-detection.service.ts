import { Injectable, Logger } from '@nestjs/common';
import { execFile } from 'child_process';
import * as path from 'path';
import * as fs from 'fs';
import { promisify } from 'util';

const execFileAsync = promisify(execFile);

interface PhishingDetectionResult {
  is_phishing: boolean;
  confidence: number;
  risk_level: string;
  message: string;
}

@Injectable()
export class MalwareDetectionService {
  private readonly logger = new Logger(MalwareDetectionService.name);
  private pythonScriptPath: string;
  private modelPath: string;
  private pythonPath: string;

  constructor() {
    // Use environment variable if available, otherwise calculate from __dirname
    const mailMalwarePath = process.env.MAIL_MALWARE_PATH ||
      path.join(__dirname, '../..', 'mail-malware-detection');

    this.pythonScriptPath = path.join(mailMalwarePath, 'src');
    this.modelPath = path.join(mailMalwarePath, 'models', 'phishing_pipeline.joblib');

    this.logger.log(`__dirname: ${__dirname}`);
    this.logger.log(`Mail malware detection path: ${mailMalwarePath}`);
    this.logger.log(`Python script path: ${this.pythonScriptPath}`);
    this.logger.log(`Model path: ${this.modelPath}`);

    // Try to find python executable - first check common locations
    this.pythonPath = this.findPythonExecutable();
  }

  private findPythonExecutable(): string {
    // First check for virtual environment python
    const venvPython = path.join(process.cwd(), '.venv', 'Scripts', 'python.exe');
    if (fs.existsSync(venvPython)) {
      this.logger.log(`Found virtual environment Python at: ${venvPython}`);
      return venvPython;
    }

    // Check parent directory for virtual environment (common in monorepos)
    const parentVenvPython = path.join(process.cwd(), '..', '.venv', 'Scripts', 'python.exe');
    if (fs.existsSync(parentVenvPython)) {
      this.logger.log(`Found virtual environment Python in parent directory at: ${parentVenvPython}`);
      return parentVenvPython;
    }

    // Common Python executable locations on Windows
    const possiblePaths = [
      'python',
      'python.exe',
      'C:\\Python312\\python.exe',
      'C:\\Python311\\python.exe',
      'C:\\Python310\\python.exe',
      'C:\\Python39\\python.exe',
      process.env.PYTHON_PATH || '',
    ];

    for (const pythonPath of possiblePaths) {
      if (pythonPath && fs.existsSync(pythonPath)) {
        this.logger.log(`Found Python at: ${pythonPath}`);
        return pythonPath;
      }
    }

    // Default fallback
    this.logger.warn('Python executable not found in common locations, using default');
    return 'python';
  }

  async detectMalware(emailData: {
    subject?: string;
    body?: string;
    sender?: string;
    headers?: string;
    receivingChain?: string | string[];
    esp?: string;
    spfPass?: boolean;
    dkimPass?: boolean;
    dmarcPass?: boolean;
    attachments?: string[];
  }): Promise<PhishingDetectionResult> {
    try {
      // Get temp directory - use OS temp directory instead for safety
      const tempDir = require('os').tmpdir();
      const tempScriptPath = path.join(tempDir, `temp_detect_${Date.now()}_${Math.random().toString(36).substr(2, 9)}.py`);

      // Format receiving chain
      let receivingChain = '';
      if (Array.isArray(emailData.receivingChain)) {
        receivingChain = emailData.receivingChain.join(';');
      } else if (typeof emailData.receivingChain === 'string') {
        receivingChain = emailData.receivingChain;
      }

      // Create Python script that uses the prediction function
      const pythonScript = `
import sys
import json
sys.path.insert(0, r'${this.pythonScriptPath}')

try:
    from predict_with_headers import predict_phishing
    
    result = predict_phishing(
        model_path=r'${this.modelPath}',
        subject=${JSON.stringify(emailData.subject || '')},
        body=${JSON.stringify(emailData.body || '')},
        receiving_chain=${JSON.stringify(receivingChain)},
        esp=${JSON.stringify(emailData.esp || 'unknown')},
        spf_pass=${emailData.spfPass ? 'True' : 'False'},
        dkim_pass=${emailData.dkimPass ? 'True' : 'False'},
        dmarc_pass=${emailData.dmarcPass ? 'True' : 'False'},
    )
    print(json.dumps(result))
except Exception as e:
    import traceback
    error_result = {
        'is_phishing': False,
        'confidence': 0,
        'risk_level': 'error',
        'message': f'Error: {str(e)}'
    }
    traceback.print_exc()
    print(json.dumps(error_result))
`;

      // Write temp script
      fs.writeFileSync(tempScriptPath, pythonScript);

      try {
        // Execute Python script using execFile (safer on Windows)
        this.logger.debug(`Executing Python: ${this.pythonPath} ${tempScriptPath}`);

        const { stdout, stderr } = await execFileAsync(this.pythonPath, [tempScriptPath], {
          maxBuffer: 10 * 1024 * 1024,
          timeout: 30000 // 30 second timeout
        });

        if (stderr) {
          this.logger.warn(`Python stderr: ${stderr}`);
        }

        const result = JSON.parse(stdout.trim());
        this.logger.log(`Phishing detection result: ${JSON.stringify(result)}`);
        return result;
      } catch (execError) {
        this.logger.error(`Python execution error: ${execError.message}`);
        this.logger.error(`Python path used: ${this.pythonPath}`);

        return {
          is_phishing: false,
          confidence: 0,
          risk_level: 'error',
          message: `Python execution failed: ${execError.message}`,
        };
      } finally {
        // Clean up temp file with delay to prevent race condition
        setTimeout(() => {
          try {
            if (fs.existsSync(tempScriptPath)) {
              fs.unlinkSync(tempScriptPath);
            }
          } catch (e) {
            // Ignore cleanup errors
          }
        }, 100);
      }
    } catch (error) {
      this.logger.error('Error in malware detection:', error);
      return {
        is_phishing: false,
        confidence: 0,
        risk_level: 'unknown',
        message: 'Error analyzing email',
      };
    }
  }

  async detectMalwareBatch(
    emails: Array<{
      subject?: string;
      body?: string;
      sender?: string;
      headers?: string;
      receivingChain?: string | string[];
      esp?: string;
      spfPass?: boolean;
      dkimPass?: boolean;
      dmarcPass?: boolean;
      attachments?: string[];
    }>
  ): Promise<PhishingDetectionResult[]> {
    const results: PhishingDetectionResult[] = [];

    for (const email of emails) {
      const result = await this.detectMalware(email);
      results.push(result);
    }

    return results;
  }
}
