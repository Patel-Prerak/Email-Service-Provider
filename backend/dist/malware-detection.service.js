"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var MalwareDetectionService_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.MalwareDetectionService = void 0;
const common_1 = require("@nestjs/common");
const child_process_1 = require("child_process");
const path = __importStar(require("path"));
const fs = __importStar(require("fs"));
const util_1 = require("util");
const execFileAsync = (0, util_1.promisify)(child_process_1.execFile);
let MalwareDetectionService = MalwareDetectionService_1 = class MalwareDetectionService {
    logger = new common_1.Logger(MalwareDetectionService_1.name);
    pythonScriptPath;
    modelPath;
    pythonPath;
    constructor() {
        const mailMalwarePath = process.env.MAIL_MALWARE_PATH ||
            path.join(__dirname, '../..', 'mail-malware-detection');
        this.pythonScriptPath = path.join(mailMalwarePath, 'src');
        this.modelPath = path.join(mailMalwarePath, 'models', 'phishing_pipeline.joblib');
        this.logger.log(`__dirname: ${__dirname}`);
        this.logger.log(`Mail malware detection path: ${mailMalwarePath}`);
        this.logger.log(`Python script path: ${this.pythonScriptPath}`);
        this.logger.log(`Model path: ${this.modelPath}`);
        this.pythonPath = this.findPythonExecutable();
    }
    findPythonExecutable() {
        const venvPython = path.join(process.cwd(), '.venv', 'Scripts', 'python.exe');
        if (fs.existsSync(venvPython)) {
            this.logger.log(`Found virtual environment Python at: ${venvPython}`);
            return venvPython;
        }
        const parentVenvPython = path.join(process.cwd(), '..', '.venv', 'Scripts', 'python.exe');
        if (fs.existsSync(parentVenvPython)) {
            this.logger.log(`Found virtual environment Python in parent directory at: ${parentVenvPython}`);
            return parentVenvPython;
        }
        const possiblePaths = [
            'python',
            'python.exe',
            'C:\\Python312\\python.exe',
            'C:\\Python311\\python.exe',
            'C:\\Python310\\python.exe',
            'C:\\Python39\\python.exe',
            process.env.PYTHON_PATH || '',
        ];
        for (const pythonPath of possiblePaths) {
            if (pythonPath && fs.existsSync(pythonPath)) {
                this.logger.log(`Found Python at: ${pythonPath}`);
                return pythonPath;
            }
        }
        this.logger.warn('Python executable not found in common locations, using default');
        return 'python';
    }
    async detectMalware(emailData) {
        try {
            const tempDir = require('os').tmpdir();
            const tempScriptPath = path.join(tempDir, `temp_detect_${Date.now()}_${Math.random().toString(36).substr(2, 9)}.py`);
            let receivingChain = '';
            if (Array.isArray(emailData.receivingChain)) {
                receivingChain = emailData.receivingChain.join(';');
            }
            else if (typeof emailData.receivingChain === 'string') {
                receivingChain = emailData.receivingChain;
            }
            const pythonScript = `
import sys
import json
sys.path.insert(0, r'${this.pythonScriptPath}')

try:
    from predict_with_headers import predict_phishing
    
    result = predict_phishing(
        model_path=r'${this.modelPath}',
        subject=${JSON.stringify(emailData.subject || '')},
        body=${JSON.stringify(emailData.body || '')},
        receiving_chain=${JSON.stringify(receivingChain)},
        esp=${JSON.stringify(emailData.esp || 'unknown')},
        spf_pass=${emailData.spfPass ? 'True' : 'False'},
        dkim_pass=${emailData.dkimPass ? 'True' : 'False'},
        dmarc_pass=${emailData.dmarcPass ? 'True' : 'False'},
    )
    print(json.dumps(result))
except Exception as e:
    import traceback
    error_result = {
        'is_phishing': False,
        'confidence': 0,
        'risk_level': 'error',
        'message': f'Error: {str(e)}'
    }
    traceback.print_exc()
    print(json.dumps(error_result))
`;
            fs.writeFileSync(tempScriptPath, pythonScript);
            try {
                this.logger.debug(`Executing Python: ${this.pythonPath} ${tempScriptPath}`);
                const { stdout, stderr } = await execFileAsync(this.pythonPath, [tempScriptPath], {
                    maxBuffer: 10 * 1024 * 1024,
                    timeout: 30000
                });
                if (stderr) {
                    this.logger.warn(`Python stderr: ${stderr}`);
                }
                const result = JSON.parse(stdout.trim());
                this.logger.log(`Phishing detection result: ${JSON.stringify(result)}`);
                return result;
            }
            catch (execError) {
                this.logger.error(`Python execution error: ${execError.message}`);
                this.logger.error(`Python path used: ${this.pythonPath}`);
                return {
                    is_phishing: false,
                    confidence: 0,
                    risk_level: 'error',
                    message: `Python execution failed: ${execError.message}`,
                };
            }
            finally {
                setTimeout(() => {
                    try {
                        if (fs.existsSync(tempScriptPath)) {
                            fs.unlinkSync(tempScriptPath);
                        }
                    }
                    catch (e) {
                    }
                }, 100);
            }
        }
        catch (error) {
            this.logger.error('Error in malware detection:', error);
            return {
                is_phishing: false,
                confidence: 0,
                risk_level: 'unknown',
                message: 'Error analyzing email',
            };
        }
    }
    async detectMalwareBatch(emails) {
        const results = [];
        for (const email of emails) {
            const result = await this.detectMalware(email);
            results.push(result);
        }
        return results;
    }
};
exports.MalwareDetectionService = MalwareDetectionService;
exports.MalwareDetectionService = MalwareDetectionService = MalwareDetectionService_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [])
], MalwareDetectionService);
//# sourceMappingURL=malware-detection.service.js.map